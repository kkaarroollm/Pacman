package models;

import constants.Direction;
import java.util.*;

public class CollisionDetector {
    private final int cellSize;
    Map<Unit, Wall> wallsMap;
    Map<Unit, EatableGrid> eatables;
    private Pacman pacman;

    public CollisionDetector(Board board, int cellSize) {
        this.pacman = null;
        this.cellSize = cellSize;
        this.wallsMap = new HashMap<>();
        this.eatables = new HashMap<>();

        for (Wall wall : board.getWalls()) {
            Unit cell = getCell(wall);
            wallsMap.put(cell, wall);
        }

        for (Coin coin : board.getCoins()) {
            Unit cell = getCell(coin);
            eatables.put(cell, coin);
        }
    }

    private Unit getCell(Grid position) {
        int cellX = position.x / cellSize;
        int cellY = position.y / cellSize;
        return new Unit(cellX, cellY);
    }

    public void setPacman(Pacman pacman) {
        System.out.println("Setting pacman");
        this.pacman = pacman;
    }

    public Pacman getPacman() {
        return this.pacman;
    }


    public boolean willCollideWithWall(MovableGrid movable) {
        int originalSpeed = movable.getSpeed();
        Direction direction = movable.getCurrentDirection();

        for (int currentSpeed = originalSpeed; currentSpeed >= 1; currentSpeed--) {
            Unit futurePosition = movable.calculateFuturePosition(currentSpeed, direction);
            Grid futureBounds = new Grid(futurePosition.getX(), futurePosition.getY(), movable.width, movable.height);

            boolean collisionDetected = false;

            for (Unit cell : getNearbyPoints(futureBounds)) {
                Wall cellWall = wallsMap.get(cell);
                if (cellWall != null && futureBounds.hit(cellWall)) {
                    collisionDetected = true;
                    break;
                }
            }

            if (!collisionDetected) {
                movable.setSpeed(currentSpeed);
                return false;
            }
        }

        return true;
    }

    public EatableGrid checkAndEatEatables() {
        Grid pacmanBounds = new Grid(this.pacman.x, this.pacman.y, this.pacman.width, this.pacman.height);

        for (Unit cell : getNearbyPoints(pacmanBounds)) {
            EatableGrid eatable = eatables.get(cell);
            if (eatable != null && pacmanBounds.overlay(eatable)) {
                eatables.remove(cell);
                return eatable;
            }
        }
        return null;
    }

    /**
     * Generates an Iterable of Units that represent the cells within the given bounds.
     * Each Unit corresponds to a cell in the grid.
     * The iterator generated by this method iterates over the cells in a row-major order,
     * starting from the top-left cell (minimal x and y coordinates) and ending at the
     * bottom-right cell (maximal x and y coordinates).
     *
     * @param gridObject The Grid object that represents the bounds of the area to search.
     * @return An Iterable of Units representing the nearby points. Each Unit represents a cell
     *         in the grid that is within the given bounds.
     */
    private Iterable<Unit> getNearbyPoints(Grid gridObject) {
        return () -> new Iterator<>() {
            int currentX = gridObject.x / cellSize; // Top left
            int currentY = gridObject.y / cellSize; // Top left
            final int maxX = (gridObject.x + gridObject.width) / cellSize; // Bottom right
            final int maxY = (gridObject.y + gridObject.height) / cellSize; // Bottom right;

            @Override
            public boolean hasNext() {
                return currentX <= maxX && currentY <= maxY;
            }

            @Override
            public Unit next() {
                Unit nextUnit = new Unit(currentX, currentY);
                currentX++;
                if (currentX > maxX) {
                    currentX = gridObject.x / cellSize;
                    currentY++;
                }
                return nextUnit;
            }
        };
    }

    public boolean canChasePacman(Ghost ghost) {
        int chaseRangeCell = 5;
        Unit ghostCell = getCell(ghost);
        Unit pacmanCell = getCell(this.pacman);

        int distanceX = Math.abs(ghostCell.getX() - pacmanCell.getX());
        int distanceY = Math.abs(ghostCell.getY() - pacmanCell.getY());
        // pitagolas
        double distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

        return distance <= chaseRangeCell;
    }
}
